/* ================================================================================

This file is part of the MinVR Open Source Project, which is developed and 
maintained collaboratively by the University of Minnesota's Interactive 
Visualization Lab and the Brown University Visualization Research Lab.

File: MinVR/MVRCore/include/MVRCore/AbstractMVRApp.H

Original Author(s) of this File: 
	Bret Jackson, 2013, University of Minnesota (inspired by VRG3D/VRApp.H)
	
Author(s) of Significant Updates/Modifications to the File:
	...

-----------------------------------------------------------------------------------
Copyright (c) 2008-2015 Regents of the University of Minnesota and Brown University
Copyright (c) 2004-2008 Brown University
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or
  other materials provided with the distribution.

* Neither the name of the University of Minnesota, Brown University, nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
================================================================================ */


#ifndef ABSTRACTMVRAPP_H
#define ABSTRACTMVRAPP_H

#include <memory>
#include <glm/glm.hpp>
#include "MVRCore/Event.H"
#include "MVRCore/ConfigVal.H"
#include "MVRCore/AbstractCamera.H"
#include "MVRCore/AbstractWindow.H"
#include <vector>

namespace MinVR {

typedef std::shared_ptr<class AbstractMVRApp> AbstractMVRAppRef;

/*! @brief Pure virtual base class for MinVR applications.
 *
 */
class AbstractMVRApp
{
public:

	AbstractMVRApp() {}
	virtual ~AbstractMVRApp() {}

	/*! @brief Handle events and computation
	 * 
	 *  This will be called once per frame.  You should do all your program's logic (handling input events,
	 *  doing any required simulation, and so on) within this function.  If you are doing any simulation or
	 *  animation where virtual objects change over time, it is useful to base this code on the time value
	 *  passed in via the synchronizedTime parameter, which is guaranteed to be synchronized across all
	 *  processes when MinVR is run in a clustered rendering environment.
	 *
	 *  @param[in] An array of events generated by devices, mice, and keyboards
	 *  @param[in] The time that has passed since the application launched in ms.
	 */
	virtual void doUserInputAndPreDrawComputation(const std::vector<EventRef> &events, double synchronizedTime) = 0;

	/*! @brief Initialize OpenGL variables.
	*
	*  This will be called once by each rendering thread as it is created. You should initialize all context
	*  specific variables here such as textures, frame buffer objects, vertex buffer objects, shaders, etc.
	*  Variables can be stored in an array and matched to the specific thread by the threadId, or alternatively,
	*  wrapped as a boost::thread_specific_ptr<> object to automatically create thread specific versions.
	*
	*  @param[in] A unique thread specific id. Ids will start at zero so that they can be used as indices in an array.
	*  @param[in] The window for the calling render thread. Can be used to get the window size, position, etc.
	*
	*  @note Initalizing opengl variables elsewhere in the application is not threadsafe!
	*/
	virtual void initializeContextSpecificVars(int threadId, WindowRef window) = 0;

	/*! @brief Initialize variables after threads are initialized.
	*
	*  This will be called once after initializeContextSpecificVars has been called from each render thread.
	*/
	virtual void postInitialization() = 0;

	/*! @brief Drawing code.
	 *  This is where all your OpenGL drawing code should go.  This routine is typically called more than
	 *  once per frame.  In a desktop VR environment, this would be called once to draw the image for the
	 *  left eye and then a second time to draw the image for the right eye.  In a 4-wall CAVE where the
	 *  a single graphics window is stretched across all the projection screens and divided into 4 different
	 *  OpenGL viewports, one per wall, this routine would be called 8 times per frame (once per eye for 
	 *  each of the walls).  Before calling this routine, MVREngine will appropriately clear the OpenGL draw
	 *  buffer(s), set the OpenGL projection matrices including applying head tracking data if applicable, 
	 *  use the OpenGL viewport command to specify the correct protion of the screen to draw if applicable, 
	 *  and/or set the stencil buffer properly to draw to stereo displays that require a left/right eye 
	 *  interlaced signal if applicable.  MVREngine determines all of those settings based upon the 
	 *  config variables passed to it at runtime that describe your VR environment.  Since all that is
	 *  handled inside MinVR, the only thing that you should implement in this function is the OpenGL
	 *  code needed to draw your scene. 
	 *
	 *  @param[in] A unique id for the current calling renderthread
	 *  @param[in] A reference to the camera, which can be used to set the current object to world transform.
	 *  @param[in] The window for the calling render thread. Can be used to get the window size, position, etc.
	 *
	 *  @note This method is called from multiple render threads. Do not modify variables in this method, as it is not thread-safe.
	 */
	virtual void drawGraphics(int threadId, AbstractCameraRef camera, WindowRef window) = 0;

};



} // end namespace

#endif


